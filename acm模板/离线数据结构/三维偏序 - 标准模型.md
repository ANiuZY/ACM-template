> 问题模型：
>
> 已知：M=1e5，a[M], b[M], c[M];
> M次询问：
> 每次给出: l1, r1, l2, r2, l3, r3;
> 每次询问: 满足 l1<a[x]<r1, l2<b[x]<r2, l3<c[x]<r3 的x的**个数**。

------

> cdq分治：
>
> 将**数据**和**询问**放入同一个数组，按照**前两维**进行排序；每1个第一二维的区间询问拆解为4个单向询问。
> 每一层归并时，只计算左边的数据对右边的询问的贡献：
> 	1 整体排序，左边整体小于右边整体，直接筛选出第一维贡献。
> 	2 归并排序，左边和右边内部分别有序，双指针筛选第二维贡献。
> 	3 树状数组，此时第一二维已经被筛选掉，所以o(logN)维护&查询这一层的答案。
> NlogN次归并，累计的答案即为最终结果。
>
> **注意：先插入数据，再插入询问，排序函数使用 stable_sort ，并且只能针对前两维进行排序，以保证数据均出现在询问的左边。**
